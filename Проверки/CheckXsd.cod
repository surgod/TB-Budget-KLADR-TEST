class "Проверка документа по XSD схеме";

import classes Константы;
import СИС2 classes СтроковыеФункции, Файл;

inclass private

const OleDomDocName: String = "Msxml2.DOMDocument.6.0";
const OleXMLSchemaName: String = "Msxml2.XMLSchemaCache.6.0";


external func CoCreateGuid(var GUID: String): Integer;
  library "ole32.dll" name "CoCreateGuid";

external func StringFromGUID2(const GUID: String; var psz: String; cbMax: Integer): Integer;
  library "ole32.dll" name 'StringFromGUID2';

func GetGUID: String;
  var vID, vStr: String;
  var vLen: Integer;
  -- получаем GUID в виде идентификатора
  vID = RepStr(' ', 8); -- = 16 bytes in unicode
  CoCreateGuid(vID);
  -- конвертируем в строку
  vStr = RepStr(' ', 50);
  vLen = StringFromGUID2(vID, vStr, 50);
  if not vLen > 0: SetError(-1, "Ошибка получения уникального идентификатора"); fi;
  Result = Trim(vStr);
end;


--var LogFile: string; -- файл протокола
--func GetErrors(sPathXML:String ;sPathXSD:String; sNameSpace:String): Integer;
--proc ViewErrors   раб.xml.ПоказатьОшибки(false,sErrLogFile);

inobject private

var asErrMsg: string[]; -- массив сообщений об ошибках
var iErrMsg:integer;    -- длина массива сообщений об ошибках
var XMLDocFileName: string; -- имя проверяемого файла
var TempXsdFolder: string; -- имя временной папки с xsd схемами для проверки
var TempLogFile: string; -- имя временного лога с ошибками
var XMLDocType: tXmlDocType; -- тип проверяемого документа

--@doc
proc OnDestroy;
  -- здесь удаляем временную папку со схемами
  inherited OnDestroy;
end;
--@doc формирование сообщения об i-ой ошибке
func GetErrorXML(aoErr: AutoObject): string;
result = format('[%d:%d] %s',
                [aoErr.line as integer,
                 aoErr.linepos as integer,
                 aoErr.reason as string
                ]);
end;

--@doc
func _GetXsdFolder: string;
  --sessioninfo.InfoBase.ProjectByName[self.ClassProject].folder+GetXsdFolder(XMLDocType);
  if XMLDocType <> nil:
    result = GetXsdFolder(XMLDocType);
  fi;
end;

-- var sPrjKladrBCPFolder: String = sessioninfo.InfoBase.ProjectByName[self.ClassProject].folder+"Shared\"+sKladrBCPFolderDyDefault;
-- --var sSrvKladrBCPFolder: String = Sessioninfo.SharedFolder + sKladrBCPFolderDyDefault;
-- var sSrvKladrBCPFolder: String = Sessioninfo.TempFolder + sKladrBCPFolderDyDefault;

proc CopyPrgFolder2LocalTempFolder;
   -- Копирование папки c xsd схемами во временную папку
  var afiles: String[];
  var iter, ifiles: Integer;
  var sPrjFolder, sLocalfolder: string;
  sPrjFolder = _GetXsdFolder;
  if existfolder(sPrjFolder):
    -- синхронизация файлов
    sLocalfolder = Sessioninfo.localfolder + GetGuid;
    if not existfolder(sLocalFolder):
      createfolder(sLocalFolder);
    fi;
    if existfolder(sLocalFolder):
      aFiles = GetFileList(sPrjFolder, "*.*", [FindOnlyFiles]);
      ifiles = LengthOfArray(aFiles);
      hint("Ждите... загрузка xsd схем для проверки документа", 0, ifiles);
      for iter = 1 .. ifiles do
        hint("Ждите... загрузка xsd схем для проверки документа", iter, ifiles);
        СинхронизироватьФайлы(aFiles[iter], sLocalFolder + "\" + ExtractFileName(aFiles[iter]));
      od;
      hint("Загрузка xsd схем для проверки документа",ifiles, ifiles);
      TempXsdFolder = sLocalFolder;
    fi;
  fi;
end;

proc RemTempFolder;
-- Удаление локальной папки c xsd схемами
  if existfolder(TempXsdFolder):
    removefolder(TempXsdFolder, true);
  fi;
end;

inobject public

var LogFile: string; -- имя файл протокола
var SaveLog: logical; -- признак сохранения протокола
var ViewLog: logical; -- признак показа протокола


--@Doc получение ошибок
proc GetErrors(sPathXML: String; sPathXSD:String; sNameSpace:String);
  --var aoDoc, aoShema: autoobject;
  var xs, xd, err, errAll, errIt: autoobject;
  var iter:integer;
  asErrMsg = nil;
  iErrMsg = 0;
  --aoDoc=AutoObject.Create(OleDomDocName);
  --aoShema=AutoObject.Create(OleXMLSchemaName);
  xd=AutoObject.Create(OleDomDocName);
  xs=AutoObject.Create(OleXMLSchemaName);
  try
    xd.Async = False;
    xd.ValidateOnParse = True;
    xd.resolveExternals = True;
    xd.SetProperty("MultipleErrorMessages", True);
    xs.add(sNameSpace, sPathXSD);
    xd.schemas = xs;
    xd.load(sPathXML);
    err = xd.parseError as Autoobject;
    try
      if err.ErrorCode as integer <> 0:
        errAll = err.allErrors as autoobject;
        try
          iErrMsg = errall.length as integer;
          for iter = 1 .. iErrMsg do
            errIt = errall.item(iter - 1) as AutoObject;
            try
              asErrMsg[iter] = GetErrorXML(errit);
            finally
              errit = nil;
            end;
          od;
        finally
          errAll = nil;
        end;
      fi;
    finally
      err = nil;
    end;
  finally
    xd = nil;
    xs = nil;
  end;
end;

--@doc просмотр ошибок
proc ViewErrors;
  var iter: integer;
  var oFile: TextFile;
  if iErrMsg > 0:
    if LogFile <> "":
      iter = Enquiry("Выберите:", format("При проверке файла обнаружено ошибок : %d. Показать?",[iErrMsg]),
             ["Показать", "В сообщения", "Протокол", "Отмена"],,itQuestion);
    else
      iter = Enquiry("Выберите:", format("При проверке файла обнаружено ошибок : %d. Показать?",[iErrMsg]),
             ["Показать", "Вывести в окно сообщений", "Отмена"],,itQuestion);
    fi;
    if iter = 1:
      asErrMsg[iErrMsg + 1] = " ";
      iter = alternate("Ошибки при проверке xml файла:", asErrMsg, 100);
      if iter <> 0:
        trace(asErrMsg[iter]);
      fi;
    elsif iter = 2:
      cleartrace;
      for iter = 1 .. iErrMsg do
        trace(asErrMsg[iter]);
      od;
    elsif iter = 3 and LogFile <> "":
      oFile = TextFile.Create(LogFile, fmCreate);
      try
        for iter = 1 .. iErrMsg do
          oFile.WriteLn(asErrMsg[iter]);
        od;
      finally
        oFile.Flush;
      end;
      OpenEditor(LogFile, true);
    fi;
  fi;
end;

--@doc количество ошибок
func CountErrors: integer;
  --result = LengthOfArray(asErrMsg);
  result = iErrMsg;
end;

end